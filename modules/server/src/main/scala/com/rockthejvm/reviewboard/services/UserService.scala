package com.rockthejvm.reviewboard.services

import java.security.SecureRandom
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.PBEKeySpec

import zio.*


import com.rockthejvm.reviewboard.domain.data.User
import com.rockthejvm.reviewboard.services.JWTService
import com.rockthejvm.reviewboard.services.EmailService
import com.rockthejvm.reviewboard.domain.data.UserSession
import com.rockthejvm.reviewboard.repositories.UserRepository
import com.rockthejvm.reviewboard.repositories.OTPRepository
import com.rockthejvm.reviewboard.domain.errors.UnauthorizedException


trait UserService {

  def registerUser(email: String, password: String): Task[User]

  def deleteUser (email: String, password: String): Task [User]

  def verifyPassword(email: String, password: String): Task[Boolean]

  def updatePassword(email: String, oldPassword: String, newPassword: String): Task [User]

  // JWT: gives the user access to a certain set of endpoints
  // JWT 'guards' those endpoints
  // acting as the "authentication bearer header" of the HTTP request
  def login(email: String, password: String): Task[Option[UserSession]]


  def sendOTP(email: String): Task[Unit]

  def resetPassword(email: String, OTP: String, newPassword: String): Task[Boolean]

}

class UserServiceLive private(
  jwtService: JWTService,
  emailService: EmailService,
  otpRepo: OTPRepository,
  userRepo: UserRepository,
) extends UserService {



  override def registerUser(email: String, password: String): Task[User] =
    userRepo.create(
      User(
        id = -1L, // generated by DB
        email = email,
        hashedPassword = UserServiceLive.Hash.generate(password)
        )
      )

  override def deleteUser(email: String, password: String): Task[User] =
    for {
      user          <- userRepo
                      .getByEmail(email)
                      .someOrFail(UnauthorizedException(s"no user with email $email"))
      isValidated   <- ZIO.attempt(UserServiceLive.Hash.validate(password, user.hashedPassword))

      deletedUser   <- userRepo
                        .delete(user.id)
                        .when(isValidated)
                        .someOrFail(new RuntimeException("Invalid Password"))

    } yield deletedUser

  override def updatePassword(email: String, oldPassword: String, newPassword: String): Task[User] =
    for {
      user          <- userRepo
                      .getByEmail(email)
                      .someOrFail(UnauthorizedException(s"no user with email $email"))
      isValidated   <- ZIO.attempt(UserServiceLive.Hash.validate(oldPassword, user.hashedPassword))
      updatedUser     <- userRepo.update(
                          user.id,
                          user => user.copy(hashedPassword=UserServiceLive.Hash.generate(newPassword))
                          ).when(isValidated).someOrFail(UnauthorizedException("### INVALID PASSWORD ###"))
    } yield updatedUser

  override def verifyPassword(email: String, password: String): Task[Boolean] =
    for {
      user          <- userRepo.getByEmail(email)
      isValidated   <- user match {
        case Some(user) => ZIO.attempt(
          UserServiceLive.Hash.validate(password, user.hashedPassword))
            .orElseSucceed(false)
        case None => ZIO.succeed(false)
      }
    } yield isValidated

  override def login(email: String, password: String): Task[Option[UserSession]] =
    for {
      user        <-userRepo
                      .getByEmail(email)
                      .someOrFail(new RuntimeException(s"no user with email $email"))
      isValidated <- ZIO.attempt(UserServiceLive.Hash.validate(password, user.hashedPassword))
      jwtToken    <- jwtService.startSession(user).when(isValidated)
    } yield jwtToken


  override def sendOTP(email: String): Task[Unit] =
    otpRepo.getOTP(email).flatMap {
      case Some(otp) => emailService.sendRecoveryEmail(email, otp)
      case None      => ZIO.unit
    }

  override def resetPassword(email: String, otp: String, newPassword: String): Task[Boolean] =
    for {
      existingUser  <- userRepo
                        .getByEmail(email)
                        .someOrFail(new RuntimeException("Non-existant user"))
      isValidOTP    <- otpRepo.checkOTP(email, otp)
      result        <- userRepo.update(
                                  existingUser.id,
                                  user => user.copy(
                                          hashedPassword=UserServiceLive.Hash.generate(newPassword)))
                                .when(isValidOTP) // Option
                                .map(_.nonEmpty) // convert to Boolean
    } yield result


}

object UserServiceLive {
  val layer = ZLayer {
    for {
    jwtService    <- ZIO.service[JWTService]
    emailService  <- ZIO.service[EmailService]
    otpRepo    <- ZIO.service[OTPRepository]
    userRepo      <- ZIO.service[UserRepository]
    } yield new UserServiceLive(jwtService, emailService, otpRepo, userRepo)
  }

  object Hash {

    // salt => randomly generated string that aids in hashing
    private val PBKDF2_ITERATIONS = 1000
    private val PBKDF2_ALGORITHM = "PBKDF2WithHmacSHA512" // Hmac -> Hash Based Message Authentication Code
    private val SALT_BYTE_SIZE = 24
    private val HASH_BYTE_SIZE = 24
    private val SEP = ":"

    private val skf: SecretKeyFactory = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM)

    // PBKDF2 => Password Based Key Derivation Function 2
    private def pbkdf2(message: Array[Char], salt: Array[Byte], iterations: Int, nBytes: Int): Array[Byte] = {
      val nBits: Int = nBytes * 8
      val keySpec: PBEKeySpec = new PBEKeySpec(message, salt, iterations, nBits)
      skf.generateSecret(keySpec).getEncoded() // Array[Byte]
    }

    private def toHex(array: Array[Byte]): String =
    // hex-encoded bytes
    // ex: "2F 4A 56" each pair of chars represents the hex-encoding of a single byte
    array.map(byte => "%02X".format(byte)).mkString

    private def fromHex(string: String): Array[Byte] =
      string.sliding(2, 2).toArray.map{
          hexValue => Integer.parseInt(hexValue, 16).toByte
      }

    private def areEqual(a: Array[Byte], b: Array[Byte]): Boolean =
      val range = 0 until Math.min(a.length, b.length)
      val sameLength: Int = a.length ^ b.length
      val diff: Int = range.foldLeft(sameLength) {
        case (acc, i) => acc | (a(i) ^ b(i))
      }
      diff == 0

    def generate(string: String) = {

      val rng: SecureRandom = new SecureRandom() // Random Number Generator
      val salt: Array[Byte] = Array.ofDim[Byte](HASH_BYTE_SIZE)

      // populate the array with random bytes
      rng.nextBytes(salt) // creates 24 random bytes

      val hashBytes = pbkdf2(string.toCharArray(), salt, PBKDF2_ITERATIONS, SALT_BYTE_SIZE)

      // yield the "final string", i.e something that can be verified later on
      // requires storing some infos: salt, nIterations
      s"${PBKDF2_ITERATIONS}$SEP${toHex(salt)}$SEP${toHex(hashBytes)}" // convert to HEX becauses bytes might have some unreadable characters

    }

    def validate(password: String, hashedPassword: String) =
      val hashSegments = hashedPassword.split(SEP)
      val nIterations = hashSegments(0).toInt
      val salt = fromHex(hashSegments(1))
      val hash = fromHex(hashSegments(2))
      val testHash = pbkdf2(password.toCharArray(), salt, nIterations, SALT_BYTE_SIZE)
      areEqual(testHash, hash)
    }
}

object UserServiceDemo {
  def main(args: Array[String]): Unit =
    val hash = UserServiceLive.Hash.generate("rockthejvm")
    println(hash)
    val isValidated = UserServiceLive.Hash.validate("rockthejvm", hash)
    println(s"isValidated=$isValidated")
}


